//https://forum.arduino.cc/t/geiger-counter-with-arduino-mkr-wifi-1010/1171212
//https://www.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt/
//https://www.google.com/search?client=firefox-b-1-d&q=arduino+geiger+counter+schematic#vhid=bbxGlvdLzpYT9M&vssid=l
//https://www.instructables.com/PKE-Meter-Geiger-Counter/

#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <toneAC.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET 4
#define NUMFLAKES 10
#define XPOS 0
#define YPOS 1
#define DELTAY 2
#define BUZZER_PIN 7
#define MEASUREMENT_SECS 40
#define NMEAS 5         // number of countrate measurements for running average
#define BATTERY_PIN A3    // pin for reading battery voltage
#define LED_PIN 10        // first LED pin

int t_int = 1000;       // integration time in ms
int counts = 0;         // number of counts per intergation time
int counts_array[NMEAS] = {0,0,0,0,0};  // array for floating average
int index = 0;          // index for floating average
double rate_cpm = 0.;    // count rate in cpm
double rate_uS_h = 0.;  // count rate in ÂµSv/h
unsigned long previousMillis_LED = 0; // ms timer for blinking LEDs
unsigned long previousMillis = 0; // ms timer for countrate calculation
unsigned long currentMillis = 0; // ms timer for countrate calculation
int LED = LED_PIN;                // current LED to blink
volatile unsigned int totalCounts = 0;
const int GEIGER = 2;
float microSeiverts = 0.00;
const int btnReset = 8;
volatile unsigned int newTicks = 0;
volatile unsigned long countsPrevious = 0;
unsigned long previousMillis1 = 0; 
const long interval = 60000;  //40000; 
const long interval1 = 500; 
int resetCounter = 0;
int buttonState = 0;
int bt = 0;
int pbt = 0;
int s1 = 0;
unsigned long j;
unsigned long CR = 0;
unsigned long cs;
int sec;
float input_voltage = 0.0;
float temp=0.0;
int clickCounter = 0;
unsigned int ticksLog[MEASUREMENT_SECS];
unsigned int tickCountsLog[MEASUREMENT_SECS];
int logsIndex = -1;
signed int ticksCount = 0;
signed int ticksCountPerSec = 0;
unsigned long tickCountsLogSum = 0;
unsigned long lastTickLogsUpdateTime = 0;
unsigned long lastVoltageReadTime = 0;
float voltage = 0;
bool hasRadioactiveMaterial = false;

//Adafruit_SSD1306 display(OLED_RESET);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

static const unsigned char PROGMEM lcd_bmp[] =
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xE0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x1C, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x0E, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x80, 0x1F, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x1F, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x80, 0x1F, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC0, 0x3F, 0xE0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x3F, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x3F, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0, 0x7F, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xE0, 0x7F, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xF0, 0x7F, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xE0, 0x7F, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xC0, 0x3F, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x03, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x40, 0x38,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x80, 0x08,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0F, 0x00, 0x08,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1F, 0x80, 0x18,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3F, 0xC0, 0x10,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0xC0, 0x30,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xFF, 0xE0, 0x20,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xFF, 0xF0, 0x40,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xFF, 0xF8, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF9, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFC, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xE0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static const unsigned char PROGMEM fl[] =
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const unsigned char PROGMEM bt1[] =
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

/*
#if (SSD1306_LCDHEIGHT != 64)
#error("Height incorrect, please fix Adafruit_SSD1306.h!");
#endif
*/

void batteryLevel() 
{

  int analog_value = analogRead(BATTERY_PIN);
  double voltage = (analog_value * 5.0) / 1024.0; 
   
   if (voltage < 0.1) 
   {
     voltage=0.0;
   }

   if(voltage > 3.3) {
    //display.drawBitmap(0, 20, bt1, 128, 32, WHITE);
    if(voltage > 3.4) {
      display.drawBitmap(0, 15, bt1, 128, 32, WHITE);
      if(voltage > 3.5) {
        display.drawBitmap(0, 10, bt1, 128, 32, WHITE);
        if(voltage > 3.6) {
          display.drawBitmap(0, 5, bt1, 128, 32, WHITE);
          if(voltage > 3.8) {
            display.drawBitmap(0, 0, bt1, 128, 32, WHITE);
          }
        }
      }
    }
   }
}

void triggerGeiger() 
{
  hasRadioactiveMaterial = true;
  delay(1);
  counts++;
  digitalWrite(BUZZER_PIN, HIGH);
  delay(1);
  digitalWrite(BUZZER_PIN, LOW);
}
 
// update count rate on display
//
void printRate() 
{
  char buffer_cpm[16];
  char buffer_uS[16];
  dtostrf(rate_cpm, 2, 0, buffer_cpm);
  dtostrf(rate_uS_h, 3, 1, buffer_uS);
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(10, 20);
  display.println(buffer_cpm);
  display.setCursor(10, 40);
  display.println(buffer_uS);
  display.setTextSize(1);
  display.setCursor(50, 25);
  display.println("cpm"); 
  display.setCursor(50, 45);
  display.println("uSv/h");
}

void countRate()
{
  currentMillis = millis();
  unsigned long dt = currentMillis - previousMillis;  // last update of display
  //unsigned long dt_LED = currentMillis - previousMillis_LED; // last update of LEDs

  // update display after integration time
  if(dt > t_int) 
  {
    display.clearDisplay();

    if(hasRadioactiveMaterial) 
    {
       display.drawBitmap(-10, 20, lcd_bmp, 128, 32, WHITE); // draw radioactive symbol
       hasRadioactiveMaterial = false;
    }

    display.drawBitmap(0, 20, fl, 128, 32, WHITE); // draw battery symbol
    
    // calculate floating average
    counts_array[index] = counts;
    int sumCounts = 0;

    for(unsigned int i = 0; i < NMEAS; ++i) 
    {
      sumCounts += counts_array[i];
    }

    index++;

    if(index == NMEAS) 
    {
      index = 0;
    }
    
    rate_cpm = (double)(sumCounts) / (double)(NMEAS) / (double)(dt) * 1000. * 60.;
    //rate_uS_h = rate_cpm * 0.0063;  // conversion according to https://www.pocketmagic.net/tube-sbm-20-%D1%81%D0%B1%D0%BC-20-geiger-tube/
    rate_uS_h = rate_cpm * 0.0067;  // conversion according to https://www.pocketmagic.net/tube-sts-5-%d1%81tc-5-geiger-tube/
    counts = 0;
    previousMillis = currentMillis;
    //moveServo();
    printRate();
    batteryLevel();
    display.display();
  }
}

void ISR_impulse() 
{ // Captures count of events from Geiger counter board
  newTicks++;
}

void drawBatteryLevel() 
{
  display.drawBitmap(0, 0, fl, 128, 32, WHITE);
  
  if (voltage > 3.3) {
    display.drawBitmap(0, 0, bt1, 128, 32, WHITE);
    if (voltage > 3.4) {
      display.drawBitmap(0, -5, bt1, 128, 32, WHITE);
      if (voltage > 3.5) {
        display.drawBitmap(0, -10, bt1, 128, 32, WHITE);
         if (voltage > 3.6) {
          display.drawBitmap(0, -15, bt1, 128, 32, WHITE);
          if (voltage > 3.8) {
            display.drawBitmap(0, -20, bt1, 128, 32, WHITE);
          }
        }
      }
    }
  }
}

void drawRadiationImage(boolean hasNewTicks) 
{
  if (hasNewTicks) {
      display.drawBitmap(-10, 20, lcd_bmp, 128, 32, WHITE);
  }
}

void drawCPM(boolean hasNewTicks)
{
  if(hasNewTicks)
  {
    display.invertDisplay(true);
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(10, 20); //My way (10, 20)
    display.clearDisplay();
    display.println(CR);
    display.setCursor(10, 38); //My way (10, 38)
    display.println(bt);
    /*
    display.println(clickCounter);
    display.setTextSize(1);
    display.setCursor(40, 38); //My way (40, 20)
    display.println("counts");
    */
    display.setCursor(40, 38); //My way (40, 38)
    display.println();
    //display.setTextSize(1);
    display.setTextSize(2);
    display.setCursor(40, 20); //My way (40, 20)
    //display.println("mR/hr");
    display.println("CPM");
  }
}

void drawMeasuredValues() 
{   
  display.setTextColor(WHITE);
  display.setTextSize(2);
  display.setCursor(10, 20);
  Serial.println("Ticks: " + String(ticksCount));
  display.print(ticksCount);
  display.setTextSize(1);
  display.println(" uR/h");

//Serial.println("Counts: " + String(totalCounts));
  display.setTextSize(2);
  display.setCursor(10, 48);
  display.print(totalCounts);
  display.println(" Counts");
/*
  display.setTextSize(2);
  display.setCursor(10, 48);
  microSeiverts = ticksCount / 100;
  display.print(microSeiverts);
  display.setTextSize(1);
  display.println(" uSv/h");
  */
  
  /*
  if(logsIndex >= 0) {
    display.setTextSize(2);
    display.setCursor(10, 48);   
    display.print(tickCountsLogSum / (logsIndex + 1)); // average ticks count
    display.setTextSize(1);
    display.println(" uR/h");
  }
  */
}

boolean isTimeOut(unsigned long& lastTimestamp, unsigned long duration) 
{
  unsigned long currentTimestamp = millis();
  
  if((currentTimestamp - lastTimestamp) < duration) 
  {
    return false;
  }
  
  lastTimestamp = currentTimestamp;

  return true;
}

void updateDisplay(boolean hasNewTicks) 
{
  display.clearDisplay(); 
  
  drawMeasuredValues();  
  drawBatteryLevel();
  drawRadiationImage(hasNewTicks);

  display.display();
}

void activateBuzzer(boolean hasNewTicks) 
{
  if (hasNewTicks) 
  {
      totalCounts++;


        //digitalWrite(BUZZER_PIN, HIGH); // buzzer ON
        //delay(1);
        //digitalWrite(BUZZER_PIN, LOW); // buzzer OFF
        //delay(100);
        Serial.println("Buzzer ON");
        toneAC(1, 10);
        delay(100);
        toneAC();

      //digitalWrite(BUZZER_PIN, HIGH); // buzzer ON
      //delay(5);


      //tone(BUZZER_PIN, 4);
      //analogWrite(BUZZER_PWM, 255);
  } 
  else 
  {
    toneAC();
      //digitalWrite(BUZZER_PIN, LOW); // buzzer OFF
      //noTone(BUZZER_PIN);
      //analogWrite(BUZZER_PWM, 0);
  }
}

void updateTicks(unsigned int newValue) 
{
  ticksCountPerSec += newValue;
  ticksCount += newValue;

  #if DEBUG
    if(newValue > 0) {
      Serial.print(millis());
      Serial.print(" ");
      Serial.print(newValue);
      Serial.print(" ");
      Serial.println(ticksCount);
    }
  #endif
}

void updateTickLogs() 
{
  if(!isTimeOut(lastTickLogsUpdateTime, 1000)) 
  {
    return;
  }
      
  if(logsIndex < (MEASUREMENT_SECS - 1)) 
  {
    logsIndex++;
  } else 
  {
    ticksCount -= ticksLog[0];
    tickCountsLogSum -= tickCountsLog[0];
    
    for(byte i = 1; i <= logsIndex; i++) 
    {
      ticksLog[i - 1] = ticksLog[i];
      tickCountsLog[i - 1] = tickCountsLog[i];
    }
  }

  ticksLog[logsIndex] = ticksCountPerSec;
  
  ticksCountPerSec = 0;
  
  tickCountsLog[logsIndex] = ticksCount;
  
  tickCountsLogSum += ticksCount;
}

void setup()
{
  Serial.begin(115200);
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.display();
  display.clearDisplay();
  display.setFont(NULL);
  delay(200);
  display.clearDisplay();

  pinMode(BUZZER_PIN, OUTPUT);

  pinMode(btnReset, INPUT_PULLUP);

  //pinMode(GEIGER, INPUT);

  //PKE code test - Mar 3rd 2024 - Before
  pinMode(GEIGER, INPUT_PULLUP);

  digitalWrite(GEIGER, HIGH);

  // Mar 3rd 2024 - Before
  //attachInterrupt(digitalPinToInterrupt(GEIGER), ISR_impulse, FALLING); 

  //PKE code test - Mar 3rd 2024 - Before
  attachInterrupt(digitalPinToInterrupt(GEIGER), triggerGeiger, LOW);

  // Mar 3rd 2024 - After
  //attachInterrupt(digitalPinToInterrupt(GEIGER), ISR_impulse, LOW); 
}

void loop() 
{
  countRate();
  /*
  //Check reset button state. If HIGH (pressed) then reset counts & display
  if(digitalRead(btnReset) == LOW)
  {
    totalCounts = 0;
    ticksCountPerSec = 0;
    ticksCount = 0;
    tickCountsLogSum = 0;
    memset(tickCountsLog, 0, sizeof(tickCountsLog));
    newTicks = 0;
    updateTicks(0);
    updateDisplay(false);
    activateBuzzer(false);
  }
  else
  {
    unsigned int _newTicks = newTicks;
    newTicks = 0;
    
    updateTicks(_newTicks);
    updateTickLogs();
    //readVoltage();
    boolean hasNewTicks = (_newTicks > 0);
      
    updateDisplay(hasNewTicks);
    activateBuzzer(hasNewTicks);
  }
  */
}